import os
import oracledb  # Oracle DB driver
import json

class DatabaseService:
    """
    Wrapper for database operations using Oracle JSON DB.
    Provides async methods for connecting and CRUD on Pokémon inventory.
    """
    _conn = None

    @classmethod
    async def connect(cls):
        """Initialize and cache the DB connection."""
        dsn = os.getenv('DB_DSN')
        user = os.getenv('DB_USER')
        pwd = os.getenv('DB_PASSWORD')
        cls._conn = oracledb.connect(user=user, password=pwd, dsn=dsn)

    @classmethod
    async def add_pokemon(cls, discord_id: int, poke_data: dict) -> int:
        """
        Insert a new Pokémon into the user's inventory.
        Returns the autogenerated inventory ID.
        """
        cur = cls._conn.cursor()
        stmt = (
            "INSERT INTO pokemon_inventory (discord_id, pokemon_data) "
            "VALUES (:1, :2) RETURNING inventory_id INTO :3"
        )
        id_var = cur.var(int)
        cur.execute(stmt, [discord_id, json.dumps(poke_data), id_var])
        cls._conn.commit()
        return id_var.getvalue()[0]

    @classmethod
    async def get_inventory(cls, discord_id: int) -> list[dict]:
        """
        Fetch all Pokémon entries for a user.
        Returns list of dicts with 'id' and Pokémon data.
        """
        cur = cls._conn.cursor()
        stmt = "SELECT inventory_id, pokemon_data FROM pokemon_inventory WHERE discord_id = :1"
        cur.execute(stmt, [discord_id])
        rows = cur.fetchall()
        return [
            { 'id': r[0], **json.loads(r[1]) }
            for r in rows
        ]

    @classmethod
    async def get_pokemon(cls, discord_id: int, inventory_id: int) -> dict | None:
        """
        Fetch a single Pokémon entry by its inventory ID.
        Returns the Pokémon data dict or None if not found.
        """
        cur = cls._conn.cursor()
        stmt = (
            "SELECT pokemon_data FROM pokemon_inventory "
            "WHERE discord_id = :1 AND inventory_id = :2"
        )
        cur.execute(stmt, [discord_id, inventory_id])
        row = cur.fetchone()
        return json.loads(row[0]) if row else None

    @classmethod
    async def update_pokemon(cls, discord_id: int, inventory_id: int, updates: dict) -> bool:
        """
        Update fields on an existing Pokémon entry.
        Returns True if updated, False if not found.
        """
        existing = await cls.get_pokemon(discord_id, inventory_id)
        if not existing:
            return False
        existing.update(updates)
        cur = cls._conn.cursor()
        stmt = (
            "UPDATE pokemon_inventory SET pokemon_data = :1 "
            "WHERE discord_id = :2 AND inventory_id = :3"
        )
        cur.execute(stmt, [json.dumps(existing), discord_id, inventory_id])
        cls._conn.commit()
        return True

    @classmethod
    async def delete_pokemon(cls, discord_id: int, inventory_id: int) -> bool:
        """
        Remove a Pokémon from a user's inventory.
        Returns True on success.
        """
        cur = cls._conn.cursor()
        stmt = "DELETE FROM pokemon_inventory WHERE discord_id = :1 AND inventory_id = :2"
        cur.execute(stmt, [discord_id, inventory_id])
        cls._conn.commit()
        return True
